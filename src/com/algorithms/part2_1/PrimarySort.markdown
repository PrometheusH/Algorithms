# 初级排序
排序是整理数据的第一步。计算时代早期，人们普遍认为30%的时间花费在排序上。
快速排序被誉为20实际**科学和工程领域**的十大算法之一。

- Example是排序的模版

最重要的两个方法：`less()`对元素进行比较，`exch()`将元素交换位置
boolean方法都可以用assert+空格+方法来进行判断。

**排序成本模型：**交换元素的，计算*比较*和*交换*的数量，不交换元素的，计算*数组的访问次数*

compareTo()方法具有`全序关系`：自反性，对于所有v，有v=v；反对称性，当v<w时，有w>v，当且仅当v=w时，w=v；传递性

# 各种初级排序
## 选择排序
在剩余元素中选择最小的，换到前面。

每个元素跟后面的所有元素比较

比较次数：(N^2)/2
> N*N的矩阵，每行比较(N-1)+(N-2)+...+2+1=N(N-1)/2

交换次数：N

### 优缺点
- 缺点：
  - 不能够利用输出的初始状态：`有序或主键全部相等的数组`**排序所用的时间**和一个`完全随机的数组`一样
  - 比较次数太多
- 优点：
  - 交换次数最少（所有的算法中，它的移动数据是最少的）
  - 不占用额外存储空间
  
## 插入排序
将一张牌插入其他已有序的牌中的相应为位置。

每个元素跟前面的元素比较（不用比较前面所有），要移动当前位置和它要去的位置之间的所有元素。

比较次数：平均(N^2)/4，最坏（逆序）（N^2）/2，最好（顺序）N-1
> 用N*N的矩阵证明

交换次数：平均（N^2）/4，最坏（N^2）/2，最好0

应用场景：非随机数组（部分有序的数组）

### 优缺点
- 缺点
  - 对于随机数组不太友好
- 优点：
  - 当倒置数量很少时，插入排序是最好的算法
- 特点：
  - 需要的交换次数和数组中倒置的数量相同
  - 需要的比较次数大于等于倒置的数量，小于等于倒置的数量+数组的大小-1

## 希尔排序
把一个数组逻辑上切分成4个4个...
将每4个的第一个组成一个小组，一共得到4个小组，每个小组内，进行插入排序，就一共进行4次
再将新的数组逻辑上切分成2个2个，
每2个的第一个组成逻辑上的小组，一共会有2个小组，对着两个小组再进行插入排序。
最后，将数组逻辑上切分成1个1个...，就是直接进行插入排序即可。

充分利用了插入排序在`小的数组`和`倒置元素少的数组`上的巨大威力。

尽量减少了无谓的移动。

需要人为地给出逻辑切分的策略。

###希尔排序优缺点：
- 优点：
  - 对中等大小的数组，它的运行时间是可以接受的。对于很大的N，最好高效的算法也最多比它快2倍，但更复杂。
  - 代码量少
  - 不需要额外的内存空间
  







